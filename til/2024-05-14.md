# TIL Template

## 날짜: 2024-05-14

### 스크럼
- 학습 목표 1 : [스크럼](https://www.notion.so/goorm/24-05-14-6a622e37a9af41ac972447bbd8753a66?pvs=4)

### 새로 배운 내용
#### 주제 1: commonjs와 es6
- 상세 내용 1: 
일단 먼저 그 안의 require와 import를 비교해보겠음.

1. require는 어디서나 사용가능. import는 파일 시작 부분에서만 가능. 다만 전용 비동기 문법으로 중간에 넣을 수 있기는 함.
2. require는 동기적으로 모듈릉 로드, import는 비동기적으로 로드. 

- 상세 내용 2: commonjs를 서버사이드에서 사용할 이유
- commonjs는 브라우저에서 사용하면 동기적 작동방식으로 인해 성능 저하 존재
- commonjs는 서버용으로 개발되어서 이미 서버에서 많이 쓰임.
- es6는 브라우저 일부 환경에서 아직 호환성이 좋지 않음. 근데 요즘은 대부분 브라우저가 최신이라 별 문제 없음
- npm에 있는 모든 라이브러리가 es6와 호환되지 않음
- 트리쉐이킹 기준으로 생각하면 서버에서 es6를 사용할 이유가 희미해짐.
- 트리 쉐이킹 기준으로 서버에서 commonjs를 써야할 이유
    
    ### **1. 성숙도와 호환성**
    
    - **CommonJS의 성숙도**: CommonJS는 Node.js 환경에서 오랜 기간 사용되어 왔으며, 대부분의 Node.js 패키지가 CommonJS 형식으로 작성되어 있습니다. 이는 CommonJS 모듈을 사용하면 호환성 문제 없이 다양한 패키지를 사용할 수 있다는 의미입니다.
    - **패키지 호환성**: 많은 npm 패키지가 여전히 CommonJS 형식으로 배포됩니다. 서버 코드에서 이러한 패키지들을 사용하는 경우, CommonJS 모듈을 사용하는 것이 더 간편합니다.
    
    ### **2. 런타임 로딩 및 동적 모듈 로딩**
    
    - **런타임 로딩**: CommonJS는 동기적이고 런타임에 모듈을 로딩합니다. 즉, **`require`** 호출이 실행될 때 모듈이 로드되고 실행됩니다. 이는 동적 모듈 로딩(dynamic module loading)을 더 쉽게 만듭니다. ES6 모듈은 정적이며, 동적 로딩을 위해서는 **`import()`**와 같은 비동기적 방식을 사용해야 합니다.
    - **동적 모듈 로딩**: 서버 환경에서는 조건에 따라 모듈을 동적으로 로딩해야 하는 경우가 많습니다. CommonJS는 이 점에서 더 유연합니다. 예를 들어, **`require`**를 조건문 안에서 사용할 수 있습니다.
    
    ### **3. 현재 트리쉐이킹의 효과**
    
    - **트리쉐이킹의 실제 효과**: 트리쉐이킹은 클라이언트 측 애플리케이션에서 번들 크기를 줄이는 데 매우 효과적입니다. 그러나 서버 애플리케이션의 경우, 전체 코드베이스를 배포하고 실행하므로 트리쉐이킹의 이점이 상대적으로 적습니다.
    - **서버 코드의 특성**: 서버 코드에서는 모든 모듈이 실행될 가능성이 높습니다. 따라서 불필요한 코드를 제거하는 트리쉐이킹의 이점이 클라이언트 측 애플리케이션만큼 크지 않을 수 있습니다.
    
    ### **4. 초기화와 모듈 스코프**
    
    - **모듈 초기화**: CommonJS는 모듈을 **`require`**할 때 즉시 실행하고, 이를 캐싱합니다. 이는 서버 환경에서 모듈 초기화와 관련된 복잡성을 줄여줄 수 있습니다.
    - **모듈 스코프**: CommonJS의 모듈 시스템은 함수 스코프를 사용하여 모듈을 격리합니다. 이는 클로저를 사용하여 전역 변수를 오염시키지 않도록 보장합니다.
    
    ### **결론**
    
    서버 환경에서는 성숙도, 패키지 호환성, 동적 로딩의 유연성, 그리고 모듈 초기화와 스코프 관리의 편리함 때문에 CommonJS를 사용하는 것이 ES6 모듈 시스템보다 더 나은 선택일 수 있습니다. 트리쉐이킹의 이점은 주로 클라이언트 측 애플리케이션에서 더 중요하며, 서버 환경에서는 이러한 이점이 상대적으로 덜 중요할 수 있습니다.


#### 주제 2: form enctype
form이 전송될 때, 인코딩 방식을 정할 수 있음. 
1. 기본값: application/x-www-form-urlencoded

모든 문자들은 서버로 보내기 전에 인코딩됨을 명시함

---

2. ultipart/form-data

모든 문자를 인코딩하지 않음을 명시함. 파일이나 이미지 전송시 주로 사용

---

3. text/plain

공백문자는 + 기호로 변환, 나머지 문자는 모두 인코딩되지 않음을 명시함

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: 로그인 post api 구현
솔직히 이거 하나가 제대로 구현되면, 이것을 활용해서 다른 api들도 만들어낼 수 있을 거라고 생각하였다. 적어도 post관련된 api들은 구현하기 쉽겠지.
하는 내내, 짜잘한 문제들이 계속 생겨서 어려웠다. 대문자, 소문자, s 하나 빼먹은 거 기타 등등. 이렇게 짜잘한 문제를 계속 해결하면서 안 좋은 습관들을 해결하고, 디버거 잘 쓰는 버릇을 길들여야 겠다는 생각빡에 안 든다.
결국 오늘 구현을 하는데 성공하였으니, 뭐 좋다.
이 문제에 대한 해결방법은 디버거를 열심히 돌려야 한다다.
내가 모든 문제를 완벽하게 설계해서 한 번에 푸는 방법은 1학년 때나 시도해볼 법한 용감한 짓이다. 그냥 꾸준하게 풀어내야지.

### 오늘의 회고
이래저래 공부를 많이 하긴 하였다. 다만 너무 짜잘한 문제들때문에 api 구현이 늦어질 것 같은 기분이다. 어쨌든 이제 완성했으니 내일 휴일기간 동안 다른 api들도 빠르게 해봐야지.

### 참고 자료 및 링크
- [노션](https://www.notion.so/0514-251996af1d764daf89d225c752c98761?pvs=4)