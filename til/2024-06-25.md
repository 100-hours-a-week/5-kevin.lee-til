## 날짜: 2024-06-25

### 스크럼
- 학습 목표 1 : [스크럼](https://www.notion.so/goorm/13-6-25-9c8c1a9bf50543af8767ff1969efddf1?pvs=4)

### 새로 배운 내용
#### 주제 1: 인증 인가 과정 중 배운 것
- 상세 내용 1 : 인증 과정의 절차

인증 절차

1. 클라이언트에서 로그인을 시도합니다.
2. 서버에서는 응답 정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여하여 세션저장소에 저장한 후, 이와 연결되는 세션ID를 발행합니다.
3. 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장을 한 후, 인증이 필요한 요청마다 쿠키를 헤더에 담아 보냅니다.
4. 서버에서는 쿠키를 받아 세션 저장소에서 대조를 한 후 대응되는 정보를 가져옵니다.
5. 인증이 완료되고 서버는 사용자에 맞는 데이터를 보내줍니다.

Session / Cookie 인증 방식은 기본적으로 세션 저장소가 필요합니다. 세션 저장소는 로그인 정보를 통해서 사용자의 정보를 저장하고 열쇠가 되는 세션ID값을 만들어 줍니다. 그리고 HTTP 헤더에 세션ID를 담아 사용자에게 보냅니다. 그러면 클라이언트에서는 쿠키로 보관하고 인증을 하는 경우에 요청에 쿠키를 담아 보냅니다. 웹 서버에서는 세션 저장소에서 쿠키(세션ID)를 받고 저장되어 있는 정보와 매칭시켜 인증을 완료합니다.

- 상세 내용 2 : 세션 내용

```java
const session = require('express-session');

app.use(session({
    secret: 'your-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: { secure: false }
}));
```

위의 코드를 server.js에서 express-session을 설정하면 req.session이 자동 생성되며 이곳에 정보를 저장할 수 있음

`credentials: 'include'` 설정은 Fetch API가 쿠키를 포함하여 요청을 보내도록 하는 설정입니다. 이 설정이 포함된 요청을 보내면 브라우저는 현재 도메인의 모든 쿠키를 요청에 자동으로 포함시킵니다. 따라서, 서버에서 세션 ID가 포함된 쿠키를 클라이언트로 전송하면, 이후의 모든 요청에서 해당 쿠키가 자동으로 포함됩니다.

예제에서 `credentials: 'include'`를 사용한 이유는, 브라우저가 서버와의 요청/응답에서 쿠키를 포함시키도록 하기 위함입니다.

```java
const response = await fetch('http://localhost:4000/users/login', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ email, password }),
    credentials: 'include'  // 쿠키를 포함하여 요청
});

```

세션 id 자체로는 암호화가 되지 않은 것이다.

왜냐면 세션 id가 대응되는 id나 키값과 전혀 상관없어도, 이를 통해 침입자가 정보를 탈취할 수 있기 때문이다. 그렇기 때문에 암호화를 칭하려면 최소한의 인코딩이 되어야 하며, 암호화를 반드시 설정해야 한다.


### 오늘의 회고
- 오늘은 쿠키와 세션을 이용한 인증,인가가 그렇게 어렵지 않다는 것을 깨달았다.
- 정확히 무엇을 구현해야하는지 범위를 정하는 날이라고 보면 될 듯.
- 지금까지는 user_id를 직접 공유하는 방식이었으나 이후부터 세션id를 공유하는 방식
- 앞으로 더 변경한다면 base64인코딩과 암호화 그리고 토큰으로 변경등이 있을 것 같다.